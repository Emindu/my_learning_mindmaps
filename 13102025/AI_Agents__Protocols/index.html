<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mind Map Visualization</title>
    <style>
        /* --- Basic Setup --- */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #343541;
            margin: 0;
            color: #ececf1;
            overflow-x: hidden;
        }
        
        /* --- Layout Container --- */
        .main-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* --- Mind Map Area --- */
        #mindmap-section {
            flex: 0 0 45vh;
            border-bottom: 2px solid #5a5c6e;
            position: relative;
            transition: flex 0.3s ease;
        }
        
        #mindmap-section.fullscreen {
            flex: 1 1 100%;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            z-index: 9999;
            border-bottom: none;
        }
        
        #mindmap-container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
            cursor: grab;
        }
        
        #mindmap-container.grabbing {
            cursor: grabbing;
        }
        
        #mindmap-content {
            position: absolute;
            transform-origin: 0 0;
            transition: transform 0.1s ease-out;
        }
        
        /* --- SVG for Lines --- */
        #mindmap-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 5000px;
            height: 5000px;
            z-index: 1; /* Behind nodes */
            pointer-events: none; /* Allows clicking through the SVG to nodes */
            overflow: visible;
        }
        
        .line-path {
            stroke: #7a7d9c;
            stroke-width: 2.5px;
            fill: none;
            transition: opacity 0.3s ease;
            opacity: 0.8;
        }

        /* --- Node Styling --- */
        .node {
            position: absolute;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 18px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            font-size: 14px;
            font-weight: 600;
            z-index: 10;
            min-width: 120px;
            max-width: 400px;
        }
        
        .node:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 16px rgba(0,0,0,0.3);
        }

        .node-text {
            flex-grow: 1;
            text-align: center;
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
            line-height: 1.4;
        }
        
        .node-text.single-line {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .node-text.multi-line {
            white-space: normal;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        
        /* Tooltip for long text */
        .node[title]:hover::after {
            content: attr(title);
            position: absolute;
            bottom: calc(100% + 10px);
            left: 50%;
            transform: translateX(-50%);
            background-color: #2a2b36;
            color: #ececf1;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            white-space: normal;
            max-width: 300px;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            pointer-events: none;
            line-height: 1.4;
        }
        
        .node-arrow {
            font-size: 16px;
            margin-left: 10px;
            margin-right: -5px;
            color: #a0a2b0;
        }
        
        .node-arrow.left {
            margin-left: -5px;
            margin-right: 10px;
        }
        
        .node-arrow.collapsed-indicator {
            font-weight: bold;
        }

        /* --- Color-coded Node Levels --- */
        .node-level-0 {
            background-color: #5d5f7b;
            border: 1px solid #7a7d9c;
        }

        .node-level-1 {
            background-color: #4b4e5a;
            border: 1px solid #636675;
        }
        
        .node-level-2 {
            background-color: #4a625a;
            border: 1px solid #627c73;
        }
        
        .node-level-3 {
            background-color: #5a5a4a;
            border: 1px solid #73736b;
        }
        
        /* --- Zoom Controls --- */
        #zoom-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 1000;
        }
        
        .zoom-btn {
            width: 40px;
            height: 40px;
            background-color: #4b4e5a;
            border: 1px solid #636675;
            border-radius: 8px;
            color: #ececf1;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .zoom-btn:hover {
            background-color: #5d5f7b;
            transform: scale(1.1);
        }
        
        /* --- Resize Handle --- */
        #resize-handle {
            height: 6px;
            background-color: #5a5c6e;
            cursor: ns-resize;
            position: relative;
            transition: background-color 0.2s ease;
        }
        
        #resize-handle:hover {
            background-color: #7a7d9c;
        }
        
        #resize-handle::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 4px;
            background-color: #a0a2b0;
            border-radius: 2px;
        }
        
        /* --- Notes Section --- */
        #notes-section {
            flex: 1;
            overflow-y: auto;
            padding: 40px;
            background: linear-gradient(135deg, #2d2e3a 0%, #25262f 100%);
            position: relative;
        }
        
        #notes-content {
            max-width: 900px;
            margin: 0 auto;
            line-height: 1.8;
            background-color: rgba(42, 43, 54, 0.6);
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }
        
        #notes-content h1 {
            color: #a8c7fa;
            font-size: 2em;
            margin-top: 0;
            margin-bottom: 0.6em;
            border-bottom: 3px solid #5a7a9c;
            padding-bottom: 0.4em;
            font-weight: 700;
        }
        
        #notes-content h2 {
            color: #8fb4e8;
            font-size: 1.6em;
            margin-top: 1.8em;
            margin-bottom: 0.6em;
            font-weight: 600;
            border-left: 4px solid #6a8fc8;
            padding-left: 12px;
        }
        
        #notes-content h3 {
            color: #b8cfe8;
            font-size: 1.3em;
            margin-top: 1.4em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }
        
        #notes-content p {
            margin: 1.2em 0;
            color: #e8eef5;
            font-size: 1.05em;
        }
        
        #notes-content ul, #notes-content ol {
            margin: 1.2em 0;
            padding-left: 2.5em;
        }
        
        #notes-content li {
            margin: 0.7em 0;
            color: #e0e8f0;
            line-height: 1.7;
        }
        
        #notes-content li::marker {
            color: #7a9fc8;
        }
        
        #notes-content code {
            background-color: #1a1b24;
            padding: 3px 8px;
            border-radius: 4px;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 0.92em;
            color: #a8c7fa;
            border: 1px solid #3a3b4a;
        }
        
        #notes-content pre {
            background-color: #1a1b24;
            padding: 18px;
            border-radius: 8px;
            overflow-x: auto;
            border: 1px solid #4a4b5a;
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        #notes-content pre code {
            background-color: transparent;
            padding: 0;
            border: none;
        }
        
        #notes-content blockquote {
            border-left: 5px solid #6a8fc8;
            padding-left: 1.2em;
            margin: 1.5em 0;
            color: #b8cfe8;
            font-style: italic;
            background-color: rgba(106, 143, 200, 0.08);
            padding: 12px 12px 12px 20px;
            border-radius: 4px;
        }
        
        #notes-content strong {
            color: #ffffff;
            font-weight: 700;
        }
        
        #notes-content em {
            color: #c0d4ea;
        }
        
        #notes-content a {
            color: #8fb4e8;
            text-decoration: none;
            border-bottom: 2px solid #6a8fc8;
            transition: all 0.2s ease;
        }
        
        #notes-content a:hover {
            color: #a8c7fa;
            border-bottom-color: #8fb4e8;
            background-color: rgba(106, 143, 200, 0.1);
        }
        
        .notes-loading {
            text-align: center;
            padding: 40px;
            color: #a0a2b0;
        }
        
        .section-title {
            position: absolute;
            top: 10px;
            left: 20px;
            font-size: 0.9em;
            color: #a0a2b0;
            font-weight: 600;
            z-index: 999;
            background-color: rgba(52, 53, 65, 0.9);
            padding: 5px 12px;
            border-radius: 4px;
        }

    </style>
</head>
<body>
    <div class="main-container">
        <!-- Mind Map Section -->
        <section id="mindmap-section">
            <div class="section-title">üó∫Ô∏è Mind Map</div>
            <div id="mindmap-container">
                <div id="mindmap-content">
                    <svg id="mindmap-svg"></svg>
                </div>
            </div>
            
            <div id="zoom-controls">
                <button class="zoom-btn" id="zoom-in" title="Zoom In">+</button>
                <button class="zoom-btn" id="zoom-out" title="Zoom Out">‚àí</button>
                <button class="zoom-btn" id="zoom-reset" title="Reset View">‚ü≤</button>
                <button class="zoom-btn" id="fullscreen-toggle" title="Toggle Fullscreen">‚õ∂</button>
            </div>
        </section>
        
        <!-- Resize Handle -->
        <div id="resize-handle"></div>
        
        <!-- Notes Section -->
        <section id="notes-section">
            <div class="section-title">üìù Notes</div>
            <div id="notes-content">
                <div class="notes-loading">Loading notes...</div>
            </div>
        </section>
    </div>

    <!-- Load mindmap data and notes from external JavaScript files -->
    <script src="mindmap_data.js"></script>
    <script src="note_data.js"></script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DATA SOURCE ---
            // mindmapData is loaded from mindmap_data.js
            // noteMarkdown is loaded from note_data.js

            const mapContainer = document.getElementById('mindmap-container');
            const mapContent = document.getElementById('mindmap-content');
            const svgContainer = document.getElementById('mindmap-svg');
            
            // --- CONFIGURATION ---
            const TEXT_THRESHOLD = 35; // Characters before wrapping to multiple lines
            const SHORT_TEXT_THRESHOLD = 20; // Characters for compact display
            const DEFAULT_EXPANSION_LEVEL = 1; // Only expand up to this level by default
            
            // --- INITIALIZE DATA WITH DEFAULT COLLAPSED STATE ---
            // Collapse all nodes at level 1 that have children (to hide level 2+)
            mindmapData.forEach(node => {
                if (node.level === DEFAULT_EXPANSION_LEVEL) {
                    // Check if this level 1 node has any children
                    const hasChildren = mindmapData.some(child => child.parent === node.id);
                    if (hasChildren) {
                        node.isCollapsed = true;
                    }
                }
            });
            
            const nodeMap = new Map(mindmapData.map(node => [node.id, node]));
            
            // --- PAN & ZOOM STATE ---
            let scale = 1;
            let translateX = 0;
            let translateY = 0;
            let isPanning = false;
            let startX = 0;
            let startY = 0;

            // --- INTERACTIVITY ---
            function toggleCollapse(nodeId) {
                const nodeData = nodeMap.get(nodeId);
                // Only toggle if the node can be collapsed (has children)
                if (nodeData && typeof nodeData.isCollapsed !== 'undefined') {
                    nodeData.isCollapsed = !nodeData.isCollapsed;
                    renderMindmap(); // Re-render the entire map
                }
            }

            // --- AUTOMATIC LAYOUT CALCULATION ---
            function calculateLayout(nodes) {
                const LEVEL_X_SPACING = 450; // Increased for wider nodes
                const NODE_Y_SPACING = 90; // Increased spacing for multi-line nodes
                const START_X = 50;
                const START_Y = 100;
                
                // Build tree structure
                const childrenMap = new Map();
                nodes.forEach(node => {
                    if (!childrenMap.has(node.parent)) {
                        childrenMap.set(node.parent, []);
                    }
                    childrenMap.get(node.parent).push(node);
                });
                
                // Calculate positions recursively
                const positions = new Map();
                let currentY = START_Y;
                
                function layoutNode(node, x, y) {
                    positions.set(node.id, { x, y });
                    
                    const children = childrenMap.get(node.id) || [];
                    if (children.length === 0) {
                        return y;
                    }
                    
                    // Calculate total height needed for children
                    const childX = x + LEVEL_X_SPACING;
                    let childY = y;
                    
                    children.forEach((child, index) => {
                        const endY = layoutNode(child, childX, childY);
                        childY = endY + NODE_Y_SPACING;
                    });
                    
                    // Center parent vertically relative to children
                    const firstChild = children[0];
                    const lastChild = children[children.length - 1];
                    const firstChildY = positions.get(firstChild.id).y;
                    const lastChildY = positions.get(lastChild.id).y;
                    const centerY = (firstChildY + lastChildY) / 2;
                    positions.set(node.id, { x, y: centerY });
                    
                    return lastChildY;
                }
                
                // Find root and start layout
                const root = nodes.find(n => n.parent === null);
                if (root) {
                    layoutNode(root, START_X, START_Y);
                }
                
                return positions;
            }

            // --- RENDERING LOGIC ---
            function getVisibleNodes() {
                const visible = [];
                for (const node of mindmapData) {
                    let isVisible = true;
                    let currentParent = node.parent ? nodeMap.get(node.parent) : null;
                    while (currentParent) {
                        if (currentParent.isCollapsed) {
                            isVisible = false;
                            break;
                        }
                        currentParent = currentParent.parent ? nodeMap.get(currentParent.parent) : null;
                    }
                    if (isVisible) {
                        visible.push(node);
                    }
                }
                return visible;
            }

            function renderMindmap() {
                // Clear existing elements
                mapContent.querySelectorAll('.node').forEach(node => node.remove());
                svgContainer.innerHTML = '';
                
                // Set SVG attributes
                svgContainer.setAttribute('width', '5000');
                svgContainer.setAttribute('height', '5000');

                const visibleNodes = getVisibleNodes();
                const visibleNodeMap = new Map(visibleNodes.map(node => [node.id, node]));
                
                // Calculate positions automatically
                const positions = calculateLayout(visibleNodes);

                visibleNodes.forEach(nodeData => {
                    const nodeEl = document.createElement('div');
                    nodeEl.id = nodeData.id;
                    nodeEl.classList.add('node', `node-level-${nodeData.level}`);
                    
                    const textEl = document.createElement('span');
                    textEl.className = 'node-text';
                    textEl.textContent = nodeData.text;
                    
                    // --- Smart text wrapping based on length ---
                    const textLength = nodeData.text.length;
                    
                    if (textLength <= SHORT_TEXT_THRESHOLD) {
                        // Short text: keep compact
                        textEl.classList.add('single-line');
                        nodeEl.style.minWidth = '120px';
                        nodeEl.style.maxWidth = '250px';
                    } else if (textLength <= TEXT_THRESHOLD) {
                        // Medium text: try to fit in one line
                        textEl.classList.add('single-line');
                        nodeEl.style.minWidth = '180px';
                        nodeEl.style.maxWidth = '350px';
                    } else {
                        // Long text: allow multiple lines
                        textEl.classList.add('multi-line');
                        nodeEl.style.minWidth = '200px';
                        nodeEl.style.maxWidth = '400px';
                        // Add tooltip for very long text
                        if (textLength > 60) {
                            nodeEl.setAttribute('title', nodeData.text);
                        }
                    }

                    // --- Add arrows and collapse/expand indicators ---
                    const hasChildren = mindmapData.some(d => d.parent === nodeData.id);
                    
                    if (nodeData.parent) {
                        const arrowEl = document.createElement('span');
                        arrowEl.className = 'node-arrow left';
                        arrowEl.textContent = '<';
                        nodeEl.appendChild(arrowEl);
                    }
                    
                    nodeEl.appendChild(textEl);
                    
                    if (hasChildren) {
                        const arrowEl = document.createElement('span');
                        arrowEl.className = 'node-arrow';
                        // Change arrow based on collapsed state
                        if (nodeData.isCollapsed) {
                            arrowEl.textContent = '+';
                            arrowEl.classList.add('collapsed-indicator');
                        } else {
                            arrowEl.textContent = '>';
                        }
                        nodeEl.appendChild(arrowEl);
                    }
                    
                    // Add click listener for interactivity
                    nodeEl.addEventListener('click', (e) => {
                        e.stopPropagation();
                        toggleCollapse(nodeData.id);
                    });

                    mapContent.appendChild(nodeEl);
                    
                    // Use calculated position
                    const pos = positions.get(nodeData.id) || { x: 0, y: 0 };
                    nodeEl.style.left = `${pos.x}px`;
                    nodeEl.style.top = `${pos.y}px`;
                });

                // --- Draw lines for visible nodes (after DOM updates) ---
                requestAnimationFrame(() => {
                    visibleNodes.forEach(nodeData => {
                        if (nodeData.parent && visibleNodeMap.has(nodeData.parent)) {
                            const parentData = visibleNodeMap.get(nodeData.parent);
                            createCurve(parentData, nodeData);
                        }
                    });
                });
            }

            function createCurve(startNodeData, endNodeData) {
                const startEl = document.getElementById(startNodeData.id);
                const endEl = document.getElementById(endNodeData.id);
                
                if (!startEl || !endEl) {
                    console.warn('Could not find elements for curve:', startNodeData.id, endNodeData.id);
                    return;
                }

                const startX = startEl.offsetLeft + startEl.offsetWidth;
                const startY = startEl.offsetTop + startEl.offsetHeight / 2;
                const endX = endEl.offsetLeft;
                const endY = endEl.offsetTop + endEl.offsetHeight / 2;
                
                const c1x = startX + (endX - startX) / 2;
                const c1y = startY;
                const c2x = endX - (endX - startX) / 2;
                const c2y = endY;

                const pathData = `M ${startX},${startY} C ${c1x},${c1y} ${c2x},${c2y} ${endX},${endY}`;
                const pathEl = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                pathEl.setAttribute('d', pathData);
                pathEl.classList.add('line-path');
                svgContainer.appendChild(pathEl);
            }
            
            // --- PAN & ZOOM FUNCTIONALITY ---
            function updateTransform() {
                mapContent.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
            }
            
            // Mouse panning
            mapContainer.addEventListener('mousedown', (e) => {
                if (e.target === mapContainer || e.target === mapContent || e.target === svgContainer) {
                    isPanning = true;
                    startX = e.clientX - translateX;
                    startY = e.clientY - translateY;
                    mapContainer.classList.add('grabbing');
                }
            });
            
            mapContainer.addEventListener('mousemove', (e) => {
                if (isPanning) {
                    translateX = e.clientX - startX;
                    translateY = e.clientY - startY;
                    updateTransform();
                }
            });
            
            mapContainer.addEventListener('mouseup', () => {
                isPanning = false;
                mapContainer.classList.remove('grabbing');
            });
            
            mapContainer.addEventListener('mouseleave', () => {
                isPanning = false;
                mapContainer.classList.remove('grabbing');
            });
            
            // Mouse wheel zoom
            mapContainer.addEventListener('wheel', (e) => {
                e.preventDefault();
                
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                const newScale = scale * delta;
                
                if (newScale >= 0.3 && newScale <= 3) {
                    // Zoom towards mouse position
                    const rect = mapContainer.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    
                    translateX = mouseX - (mouseX - translateX) * delta;
                    translateY = mouseY - (mouseY - translateY) * delta;
                    scale = newScale;
                    
                    updateTransform();
                }
            });
            
            // Zoom controls
            document.getElementById('zoom-in').addEventListener('click', () => {
                if (scale < 3) {
                    scale *= 1.2;
                    updateTransform();
                }
            });
            
            document.getElementById('zoom-out').addEventListener('click', () => {
                if (scale > 0.3) {
                    scale *= 0.8;
                    updateTransform();
                }
            });
            
            document.getElementById('zoom-reset').addEventListener('click', () => {
                scale = 1;
                translateX = 0;
                translateY = 0;
                updateTransform();
            });
            
            // --- FULLSCREEN TOGGLE ---
            const mindmapSection = document.getElementById('mindmap-section');
            const notesSection = document.getElementById('notes-section');
            const resizeHandle = document.getElementById('resize-handle');
            let isFullscreen = false;
            
            document.getElementById('fullscreen-toggle').addEventListener('click', () => {
                isFullscreen = !isFullscreen;
                
                if (isFullscreen) {
                    mindmapSection.classList.add('fullscreen');
                    notesSection.style.display = 'none';
                    resizeHandle.style.display = 'none';
                } else {
                    mindmapSection.classList.remove('fullscreen');
                    notesSection.style.display = 'block';
                    resizeHandle.style.display = 'block';
                }
            });
            
            // --- RESIZE HANDLE FUNCTIONALITY ---
            let isResizing = false;
            let startResizeY = 0;
            let startMindmapHeight = 0;
            
            resizeHandle.addEventListener('mousedown', (e) => {
                isResizing = true;
                startResizeY = e.clientY;
                const mindmapRect = mindmapSection.getBoundingClientRect();
                startMindmapHeight = mindmapRect.height;
                document.body.style.cursor = 'ns-resize';
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (isResizing) {
                    const deltaY = e.clientY - startResizeY;
                    const newHeight = startMindmapHeight + deltaY;
                    const windowHeight = window.innerHeight;
                    
                    // Constrain between 20vh and 80vh
                    const minHeight = windowHeight * 0.2;
                    const maxHeight = windowHeight * 0.8;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        const heightVh = (newHeight / windowHeight) * 100;
                        mindmapSection.style.flex = `0 0 ${heightVh}vh`;
                    }
                }
            });
            
            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    document.body.style.cursor = '';
                }
            });
            
            // Initial render
            renderMindmap();
            updateTransform();
            window.addEventListener('resize', renderMindmap);
            
            // --- LOAD AND RENDER MARKDOWN NOTES ---
            function loadNotes() {
                const notesContent = document.getElementById('notes-content');
                
                try {
                    // noteMarkdown is loaded from note_data.js
                    if (typeof noteMarkdown === 'undefined' || !noteMarkdown) {
                        throw new Error('Notes data not found');
                    }
                    
                    const markdown = noteMarkdown;
                    
                    // Simple markdown to HTML conversion
                    let html = markdown
                        // Headers
                        .replace(/^### (.*$)/gm, '<h3>$1</h3>')
                        .replace(/^## (.*$)/gm, '<h2>$1</h2>')
                        .replace(/^# (.*$)/gm, '<h1>$1</h1>')
                        // Bold
                        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                        // Italic
                        .replace(/\*(.*?)\*/g, '<em>$1</em>')
                        // Code blocks
                        .replace(/```([^`]+)```/g, '<pre><code>$1</code></pre>')
                        // Inline code
                        .replace(/`([^`]+)`/g, '<code>$1</code>')
                        // Links
                        .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank">$1</a>')
                        // Unordered lists
                        .replace(/^\- (.*$)/gm, '<li>$1</li>')
                        // Blockquotes
                        .replace(/^> (.*$)/gm, '<blockquote>$1</blockquote>')
                        // Line breaks to paragraphs
                        .replace(/\n\n/g, '</p><p>')
                        .replace(/\n/g, '<br>');
                    
                    // Wrap in paragraph tags
                    html = '<p>' + html + '</p>';
                    
                    // Wrap lists in ul tags
                    html = html.replace(/(<li>.*?<\/li>)/gs, '<ul>$1</ul>');
                    
                    // Clean up empty paragraphs
                    html = html.replace(/<p><\/p>/g, '');
                    html = html.replace(/<p><br><\/p>/g, '');
                    
                    notesContent.innerHTML = html;
                    
                } catch (error) {
                    console.error('Error loading notes:', error);
                    notesContent.innerHTML = `
                        <div class="notes-loading">
                            <p>üìù No notes available</p>
                            <p style="font-size: 0.9em; color: #7a7d9c;">The note data could not be loaded.</p>
                        </div>
                    `;
                }
            }
            
            // Load notes
            loadNotes();
        });
    </script>
</body>
</html>

